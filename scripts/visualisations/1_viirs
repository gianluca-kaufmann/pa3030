# analyze_viirs_all_years.py
# Analysis + visualization for cleaned VIIRS night light data (nW/cm²/sr)
# GeoTIFFs for multiple years - creates linear scale visualizations

import os
import numpy as np
import rasterio
import matplotlib.pyplot as plt

plt.rcParams.update({"figure.autolayout": True})

def analyze_and_visualize_viirs_year(year, tif_path, output_dir, vmax=5):
    """
    Analyze and visualize a cleaned VIIRS night light raster for a specific year.

    Parameters
    ----------
    year : int
        Year label used in titles and filenames (e.g., 2012, 2017, 2022).
    tif_path : str
        Path to the cleaned VIIRS GeoTIFF (single-band expected, nW/cm²/sr).
    output_dir : str
        Directory to save visualization.
    vmax : float
        Maximum value for color scale (default: 0.4 nW/cm²/sr).

    Returns
    -------
    dict
        Summary statistics and metadata for the year.
    """
    assert os.path.exists(tif_path), f"File not found: {tif_path}"

    with rasterio.open(tif_path) as src:
        data = src.read(1)
        crs = src.crs
        bounds = src.bounds
        nodata = src.nodata
        res_x, res_y = src.res

    # Cast to float, build valid mask
    data = data.astype("float64")
    if nodata is not None:
        valid = data != nodata
        data = np.where(valid, data, np.nan)
    else:
        valid = ~np.isnan(data)

    # VIIRS should be non-negative
    data = np.where(np.isfinite(data), np.maximum(data, 0.0), data)

    # Stats on valid pixels
    v = data[valid]
    v = v[np.isfinite(v)]
    n_valid = v.size
    n_zero = np.count_nonzero(v == 0)
    n_nonzero = n_valid - n_zero

    if n_valid == 0:
        raise ValueError(f"No valid pixels found in {tif_path}")

    # Basic stats
    v_min, v_max = float(np.min(v)), float(np.max(v))
    v_mean = float(np.mean(v))
    v_median = float(np.median(v))
    v_std = float(np.std(v))
    p90 = float(np.percentile(v, 90))
    p95 = float(np.percentile(v, 95))
    p97 = float(np.percentile(v, 97))
    p99 = float(np.percentile(v, 99))
    share_nonzero = 100.0 * n_nonzero / n_valid

    # VIIRS-specific thresholds
    gt_1 = 100.0 * np.count_nonzero(v > 1) / n_valid
    gt_10 = 100.0 * np.count_nonzero(v > 10) / n_valid
    gt_100 = 100.0 * np.count_nonzero(v > 100) / n_valid

    # Print summary
    print(f"\n=== Cleaned VIIRS {year} — Summary ===")
    print(f"Path: {tif_path}")
    print(f"Shape: {data.shape} (rows, cols)")
    print(f"CRS: {crs}")
    print(f"Resolution: {res_x} x {res_y} (CRS units per pixel)")
    print(f"Bounds: {bounds}")
    print(f"NoData: {nodata}")
    print(f"Valid pixels: {n_valid:,}")
    print(f"Non-zero pixels: {n_nonzero:,} ({share_nonzero:.2f}%)")
    print(f"Min / Max: {v_min:.6g} / {v_max:.6g} nW/cm²/sr")
    print(f"Mean / Median / Std: {v_mean:.6g} / {v_median:.6g} / {v_std:.6g}")
    print(f"P90 / P95 / P97 / P99: {p90:.6g} / {p95:.6g} / {p97:.6g} / {p99:.6g}")
    print(f"Share >1 / >10 / >100 nW/cm²/sr: {gt_1:.2f}% / {gt_10:.2f}% / {gt_100:.2f}%")

    # Create output directory
    os.makedirs(output_dir, exist_ok=True)

    extent = (bounds.left, bounds.right, bounds.bottom, bounds.top)

    # Linear map with standardized scale
    plt.figure(figsize=(12, 10))
    im = plt.imshow(np.where(np.isfinite(data), data, np.nan),
                    extent=extent, origin='upper', cmap='viridis',
                    vmin=0, vmax=vmax)
    cbar = plt.colorbar(im, shrink=0.8)
    cbar.set_label('Night Light Intensity (nW/cm²/sr)', rotation=270, labelpad=15)
    plt.title(f"Cleaned VIIRS Night Lights — {year} (max={vmax} nW/cm²/sr)", fontsize=14, pad=20)
    plt.xlabel(f"X ({crs.to_string() if crs else ''})")
    plt.ylabel(f"Y ({crs.to_string() if crs else ''})")
    
    # Save plot
    output_filename = f"viirs_{year}_cleaned_linear.png"
    output_path = os.path.join(output_dir, output_filename)
    plt.savefig(output_path, dpi=200, bbox_inches='tight')
    plt.close()

    print(f"\nSaved visualization: {output_path}")

    return {
        "year": year,
        "path": tif_path,
        "shape": data.shape,
        "crs": crs,
        "resolution": (res_x, res_y),
        "bounds": bounds,
        "nodata": nodata,
        "n_valid": int(n_valid),
        "n_nonzero": int(n_nonzero),
        "share_nonzero_pct": share_nonzero,
        "min": v_min,
        "max": v_max,
        "mean": v_mean,
        "median": v_median,
        "std": v_std,
        "p90": p90,
        "p95": p95,
        "p97": p97,
        "p99": p99,
        "pct_gt_1": gt_1,
        "pct_gt_10": gt_10,
        "pct_gt_100": gt_100,
        "visualization": output_path,
    }

def main():
    """
    Analyze cleaned VIIRS rasters for multiple years and create visualizations.
    """
    print("VIIRS Cleaned Data Analysis and Visualization")
    print("=" * 60)
    
    # Configuration
    base_dir = "/Users/gianluca/Desktop/Master's Thesis/code"
    data_dir = os.path.join(base_dir, "data")
    output_dir = os.path.join(base_dir, "outputs", "figures")
    
    # Input files (cleaned datasets)
    years_data = {
        2012: os.path.join(data_dir, "viirs_2012_cleaned.tif"),
        2017: os.path.join(data_dir, "viirs_2017_cleaned.tif"),
        2022: os.path.join(data_dir, "viirs_2022_cleaned.tif"),
    }
    
    # Visualization parameters
    vmax_standardized = 5  # Standardized maximum for color scale
    
    # Process each year
    results = {}
    for year, input_path in years_data.items():
        try:
            result = analyze_and_visualize_viirs_year(
                year=year,
                tif_path=input_path,
                output_dir=output_dir,
                vmax=vmax_standardized
            )
            results[year] = result
            
        except Exception as e:
            print(f"Error analyzing {year}: {e}")
            continue

    if len(results) > 1:
        print("\n" + "="*60)
        print("SUMMARY COMPARISON ACROSS YEARS (Cleaned VIIRS)")
        print("="*60)
        for y in sorted(results.keys()):
            r = results[y]
            print(f"\n{y}:")
            print(f"  Mean intensity: {r['mean']:.6g} nW/cm²/sr")
            print(f"  Median intensity: {r['median']:.6g} nW/cm²/sr")
            print(f"  P90 / P95 / P97 / P99: {r['p90']:.6g} / {r['p95']:.6g} / {r['p97']:.6g} / {r['p99']:.6g}")
            print(f"  Share non-zero: {r['share_nonzero_pct']:.2f}%")
            print(f"  % cells >1 / >10 / >100: {r['pct_gt_1']:.2f}% / {r['pct_gt_10']:.2f}% / {r['pct_gt_100']:.2f}%")
        
        # Optional deltas
        ys = sorted(results.keys())
        if len(ys) >= 2:
            print("\nDeltas (later - earlier):")
            for a, b in zip(ys[:-1], ys[1:]):
                dm = results[b]['mean'] - results[a]['mean']
                dmed = results[b]['median'] - results[a]['median']
                dnz = results[b]['share_nonzero_pct'] - results[a]['share_nonzero_pct']
                print(f"  {a} → {b}: ΔMean={dm:.6g}, ΔMedian={dmed:.6g}, ΔShareNonZero={dnz:.2f} pp")
        
        # Data quality summary
        print(f"\nData Quality Summary (Cleaned Data):")
        for y in sorted(results.keys()):
            r = results[y]
            quality_notes = []
            if r['share_nonzero_pct'] < 30:
                quality_notes.append("✓ Realistic coverage")
            if r['max'] < 100:
                quality_notes.append("✓ No extreme outliers")
            if r['min'] >= 0:
                quality_notes.append("✓ No negative values")
            
            if quality_notes:
                print(f"  {y}: {' | '.join(quality_notes)}")
            else:
                print(f"  {y}: No major issues detected")

    print(f"\nVisualizations saved to: {output_dir}")
    print("All plots use standardized color scale (max=5 nW/cm²/sr)")

if __name__ == "__main__":
    main()