# analyze_gpw_all_years.py
# Minimal analysis + visualization for GPWv4.11 population density (persons/km^2)
# GeoTIFFs for multiple years.

import os
import numpy as np
import rasterio
import matplotlib.pyplot as plt

plt.rcParams.update({"figure.autolayout": True})

def analyze_gpw_year(year, tif_path, make_log_map=True):
    """
    Analyze and visualize a GPW population density raster for a specific year.

    Parameters
    ----------
    year : int
        Year label used in titles and filenames (e.g., 2012, 2017, 2022).
    tif_path : str
        Path to the GPW GeoTIFF (single-band expected, persons/km^2).
    make_log_map : bool
        If True, also produce a log-scaled map (natural log of density+1).

    Returns
    -------
    dict
        Summary statistics and metadata for the year.
    """
    assert os.path.exists(tif_path), f"File not found: {tif_path}"

    with rasterio.open(tif_path) as src:
        arr = src.read(1)
        crs = src.crs
        bounds = src.bounds
        nodata = src.nodata
        res_x, res_y = src.res

    # Cast to float, build valid mask
    data = arr.astype("float64")
    if nodata is not None:
        valid = data != nodata
        data = np.where(valid, data, np.nan)
    else:
        valid = ~np.isnan(data)

    # GPW should be non-negative. Keep zeros (important signal for sparsely populated cells).
    # If any small negatives slipped in, clamp to 0 without touching NaNs:
    data = np.where(np.isfinite(data), np.maximum(data, 0.0), data)

    # Stats on valid pixels
    v = data[valid]
    v = v[np.isfinite(v)]
    n_valid = v.size
    n_zero = np.count_nonzero(v == 0)
    n_nonzero = n_valid - n_zero

    if n_valid == 0:
        raise ValueError(f"No valid pixels found in {tif_path}")

    # Basic stats
    v_min, v_max = float(np.min(v)), float(np.max(v))
    v_mean = float(np.mean(v))
    v_median = float(np.median(v))
    v_std = float(np.std(v))
    p90 = float(np.percentile(v, 90))
    p95 = float(np.percentile(v, 95))
    p97 = float(np.percentile(v, 97))
    p99 = float(np.percentile(v, 99))
    share_nonzero = 100.0 * n_nonzero / n_valid

    # Some density thresholds (useful for QA)
    gt_100 = 100.0 * np.count_nonzero(v > 100) / n_valid
    gt_1000 = 100.0 * np.count_nonzero(v > 1000) / n_valid

    # Print summary
    print(f"\n=== GPW {year} — Quick Summary ===")
    print(f"Path: {tif_path}")
    print(f"Shape: {data.shape} (rows, cols)")
    print(f"CRS: {crs}")
    print(f"Resolution: {res_x} x {res_y} (CRS units per pixel)")
    print(f"Bounds: {bounds}")
    print(f"NoData: {nodata}")
    print(f"Valid pixels: {n_valid:,}")
    print(f"Non-zero pixels: {n_nonzero:,} ({share_nonzero:.2f}%)")
    print(f"Min / Max: {v_min:.6g} / {v_max:.6g} persons/km²")
    print(f"Mean / Median / Std: {v_mean:.6g} / {v_median:.6g} / {v_std:.6g}")
    print(f"P90 / P95 / P97 / P99: {p90:.6g} / {p95:.6g} / {p97:.6g} / {p99:.6g}")
    print(f"Share >100 / >1000 persons/km²: {gt_100:.2f}% / {gt_1000:.2f}%")

    # Figures dir
    os.makedirs("outputs/figures", exist_ok=True)

    extent = (bounds.left, bounds.right, bounds.bottom, bounds.top)

    # Linear map (0 to P97)
    vmax_lin = p97 if p97 > 0 else v_max if v_max > 0 else 1.0
    plt.figure(figsize=(10, 8))
    im = plt.imshow(np.where(np.isfinite(data), data, np.nan),
                    extent=extent, origin='upper', cmap='viridis',
                    vmin=0, vmax=vmax_lin)
    cbar = plt.colorbar(im, shrink=0.8)
    cbar.set_label('Population density (persons/km²), linear up to P97')
    plt.title(f"GPW Population Density — {year} (linear)")
    plt.xlabel(f"X ({crs.to_string() if crs else ''})")
    plt.ylabel(f"Y ({crs.to_string() if crs else ''})")
    out_lin = f"outputs/figures/gpw_{year}_map_linear.png"
    plt.savefig(out_lin, dpi=200)
    plt.close()

    out_log = None
    if make_log_map:
        # Log map using ln(density + 1) to handle zeros
        log_data = np.where(np.isfinite(data), np.log1p(np.maximum(data, 0.0)), np.nan)
        vmax_log = float(np.nanpercentile(log_data, 97)) if np.isfinite(log_data).any() else 1.0
        plt.figure(figsize=(10, 8))
        im2 = plt.imshow(log_data, extent=extent, origin='upper', cmap='viridis',
                         vmin=0, vmax=vmax_log)
        cbar2 = plt.colorbar(im2, shrink=0.8)
        cbar2.set_label('ln(pop density + 1), up to P97')
        plt.title(f"GPW Population Density — {year} (log scale)")
        plt.xlabel(f"X ({crs.to_string() if crs else ''})")
        plt.ylabel(f"Y ({crs.to_string() if crs else ''})")
        out_log = f"outputs/figures/gpw_{year}_map_log.png"
        plt.savefig(out_log, dpi=200)
        plt.close()

    print("\nSaved figures:")
    print(f" - {out_lin}")
    if out_log:
        print(f" - {out_log}")

    return {
        "year": year,
        "path": tif_path,
        "shape": data.shape,
        "crs": crs,
        "resolution": (res_x, res_y),
        "bounds": bounds,
        "nodata": nodata,
        "n_valid": int(n_valid),
        "n_nonzero": int(n_nonzero),
        "share_nonzero_pct": share_nonzero,
        "min": v_min,
        "max": v_max,
        "mean": v_mean,
        "median": v_median,
        "std": v_std,
        "p90": p90,
        "p95": p95,
        "p97": p97,
        "p99": p99,
        "pct_gt_100": gt_100,
        "pct_gt_1000": gt_1000,
        "map_linear": out_lin,
        "map_log": out_log,
    }

def main():
    """
    Analyze GPW rasters for multiple years and print a concise comparison.
    Update the paths below to your exported GeoTIFFs.
    """
    # Map your *target* years to the paths you exported.
    # (Remember: 2012 uses GPW 2010 snapshot, 2017 uses 2015, 2022 uses 2020.)
    years_data = {
        # TODO: Replace with your actual file paths from GEE exports
        # Examples:
        2012: "/Users/gianluca/Desktop/Master's Thesis/code/data/gpw_2012.tif",
        2017: "/Users/gianluca/Desktop/Master's Thesis/code/data/gpw_2017.tif",
        2022: "/Users/gianluca/Desktop/Master's Thesis/code/data/gpw_2022.tif",
    }

    results = {}
    for y, p in years_data.items():
        try:
            res = analyze_gpw_year(y, p, make_log_map=True)
            results[y] = res
        except Exception as e:
            print(f"Error analyzing {y}: {e}")

    if len(results) > 1:
        print("\n" + "="*60)
        print("SUMMARY COMPARISON ACROSS YEARS (GPW)")
        print("="*60)
        for y in sorted(results.keys()):
            r = results[y]
            print(f"\n{y}:")
            print(f"  Mean density: {r['mean']:.6g} persons/km²")
            print(f"  Median density: {r['median']:.6g} persons/km²")
            print(f"  P90 / P95 / P97 / P99: {r['p90']:.6g} / {r['p95']:.6g} / {r['p97']:.6g} / {r['p99']:.6g}")
            print(f"  Share non-zero: {r['share_nonzero_pct']:.2f}%")
            print(f"  % cells >100 / >1000: {r['pct_gt_100']:.2f}% / {r['pct_gt_1000']:.2f}%")
        # Optional deltas
        ys = sorted(results.keys())
        if len(ys) >= 2:
            print("\nDeltas (later - earlier):")
            for a, b in zip(ys[:-1], ys[1:]):
                dm = results[b]['mean'] - results[a]['mean']
                dmed = results[b]['median'] - results[a]['median']
                dnz = results[b]['share_nonzero_pct'] - results[a]['share_nonzero_pct']
                print(f"  {a} → {b}: ΔMean={dm:.6g}, ΔMedian={dmed:.6g}, ΔShareNonZero={dnz:.2f} pp")

if __name__ == "__main__":
    main()