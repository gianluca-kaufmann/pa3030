#!/usr/bin/env python3
"""
WorldClim BIO Visualization for South America

This script creates visualizations of the WorldClim bioclimatic variables
which contain 19 bands representing different climate indicators at 1km resolution.
The data represents climatological averages from 1960-1991.
"""

import numpy as np
import rasterio
import matplotlib.pyplot as plt
from pathlib import Path
import warnings
from matplotlib.colors import ListedColormap
import glob

warnings.filterwarnings('ignore')

# Set up paths
data_dir = Path("/Users/gianluca/Desktop/Master's Thesis/code/data")
worldclim_dir = data_dir / "WorldClim"
output_dir = Path("/Users/gianluca/Desktop/Master's Thesis/code/outputs/Figures/WorldClim_vis")
output_dir.mkdir(parents=True, exist_ok=True)

# WorldClim BIO band names and descriptions
WORLDCLIM_BANDS = {
    'bio01': {'description': 'Annual Mean Temperature', 'unit': '¬∞C', 'cmap': 'RdYlBu_r', 'scale_factor': 0.1},
    'bio02': {'description': 'Mean Diurnal Range', 'unit': '¬∞C', 'cmap': 'viridis', 'scale_factor': 0.1},
    'bio03': {'description': 'Isothermality', 'unit': '%', 'cmap': 'plasma', 'scale_factor': 0.1},
    'bio04': {'description': 'Temperature Seasonality', 'unit': '¬∞C', 'cmap': 'inferno', 'scale_factor': 0.01},
    'bio05': {'description': 'Max Temperature of Warmest Month', 'unit': '¬∞C', 'cmap': 'Reds', 'scale_factor': 0.1},
    'bio06': {'description': 'Min Temperature of Coldest Month', 'unit': '¬∞C', 'cmap': 'Blues', 'scale_factor': 0.1},
    'bio07': {'description': 'Temperature Annual Range', 'unit': '¬∞C', 'cmap': 'Oranges', 'scale_factor': 0.1},
    'bio08': {'description': 'Mean Temperature of Wettest Quarter', 'unit': '¬∞C', 'cmap': 'RdYlBu_r', 'scale_factor': 0.1},
    'bio09': {'description': 'Mean Temperature of Driest Quarter', 'unit': '¬∞C', 'cmap': 'RdYlBu_r', 'scale_factor': 0.1},
    'bio10': {'description': 'Mean Temperature of Warmest Quarter', 'unit': '¬∞C', 'cmap': 'Reds', 'scale_factor': 0.1},
    'bio11': {'description': 'Mean Temperature of Coldest Quarter', 'unit': '¬∞C', 'cmap': 'Blues', 'scale_factor': 0.1},
    'bio12': {'description': 'Annual Precipitation', 'unit': 'mm', 'cmap': 'Blues', 'scale_factor': 1.0},
    'bio13': {'description': 'Precipitation of Wettest Month', 'unit': 'mm', 'cmap': 'Blues', 'scale_factor': 1.0},
    'bio14': {'description': 'Precipitation of Driest Month', 'unit': 'mm', 'cmap': 'Oranges', 'scale_factor': 1.0},
    'bio15': {'description': 'Precipitation Seasonality', 'unit': '%', 'cmap': 'viridis', 'scale_factor': 1.0},
    'bio16': {'description': 'Precipitation of Wettest Quarter', 'unit': 'mm', 'cmap': 'Blues', 'scale_factor': 1.0},
    'bio17': {'description': 'Precipitation of Driest Quarter', 'unit': 'mm', 'cmap': 'Oranges', 'scale_factor': 1.0},
    'bio18': {'description': 'Precipitation of Warmest Quarter', 'unit': 'mm', 'cmap': 'Blues', 'scale_factor': 1.0},
    'bio19': {'description': 'Precipitation of Coldest Quarter', 'unit': 'mm', 'cmap': 'Blues', 'scale_factor': 1.0}
}

def load_worldclim_data():
    """Load the WorldClim BIO data from all tile files and mosaic them"""
    print("üìÅ Loading WorldClim BIO data from tile files...")
    
    # Find all WorldClim tile files
    tile_files = list(worldclim_dir.glob("WorldClim_BIO_SA_1km-*.tif"))
    
    if not tile_files:
        print("   ‚ùå No WorldClim files found")
        return None
    
    print(f"   üìä Found {len(tile_files)} tile files")
    
    # Read all tiles and combine them
    all_tiles = []
    combined_bounds = None
    reference_src = None
    
    for tile_file in sorted(tile_files):
        try:
            with rasterio.open(tile_file) as src:
                data = src.read()
                bounds = src.bounds
                
                print(f"   ‚úÖ {tile_file.name}: Shape: {data.shape}, Bounds: {bounds}")
                
                all_tiles.append({
                    'data': data,
                    'bounds': bounds,
                    'src': src
                })
                
                # Keep reference to first source for metadata
                if reference_src is None:
                    reference_src = src
                
                # Update combined bounds
                if combined_bounds is None:
                    combined_bounds = bounds
                else:
                    combined_bounds = rasterio.coords.BoundingBox(
                        min(combined_bounds.left, bounds.left),
                        min(combined_bounds.bottom, bounds.bottom),
                        max(combined_bounds.right, bounds.right),
                        max(combined_bounds.top, bounds.top)
                    )
                
        except Exception as e:
            print(f"   ‚ùå Error loading {tile_file.name}: {e}")
            continue
    
    if not all_tiles:
        print("   ‚ùå No tiles loaded successfully")
        return None
    
    # Mosaic all tiles to get complete South America coverage
    print("   üîß Mosaicking tiles for complete coverage...")
    
    # Calculate the mosaic dimensions
    mosaic_width = int((combined_bounds.right - combined_bounds.left) / 1000)  # 1km resolution
    mosaic_height = int((combined_bounds.top - combined_bounds.bottom) / 1000)
    
    print(f"   üìä Mosaic dimensions: {mosaic_width} x {mosaic_height}")
    
    # Create mosaic array
    mosaic_data = np.full((19, mosaic_height, mosaic_width), np.nan, dtype=np.float32)
    
    # Fill mosaic with tile data
    for tile_info in all_tiles:
        data = tile_info['data']
        bounds = tile_info['bounds']
        
        # Calculate position in mosaic
        left_offset = int((bounds.left - combined_bounds.left) / 1000)
        top_offset = int((combined_bounds.top - bounds.top) / 1000)
        
        # Place tile data in mosaic
        tile_height, tile_width = data.shape[1], data.shape[2]
        mosaic_data[:, top_offset:top_offset+tile_height, left_offset:left_offset+tile_width] = data
    
    print(f"   üìä Mosaic data shape: {mosaic_data.shape}")
    print(f"   üìä Valid pixels: {np.sum(~np.isnan(mosaic_data)):,}")
    
    return {
        'data': mosaic_data,
        'src': reference_src,
        'bounds': combined_bounds,
        'band_names': list(WORLDCLIM_BANDS.keys()),
        'file_path': tile_files[0]  # Keep reference to first file
    }

def create_overview_visualization(data_info):
    """Create overview visualization for all bioclimatic variables"""
    if data_info is None:
        return
    
    print("üé® Creating overview visualization for all bioclimatic variables...")
    
    data = data_info['data']
    band_names = data_info['band_names']
    
    # Create 4x5 grid for 19 bands (with one empty space)
    fig, axes = plt.subplots(4, 5, figsize=(20, 16))
    fig.suptitle('WorldClim Bioclimatic Variables - South America (1960-1991 Average)', 
                fontsize=16, fontweight='bold')
    
    axes_flat = axes.flatten()
    
    for band_idx, band_name in enumerate(band_names):
        ax = axes_flat[band_idx]
        band_data = data[band_idx]
        
        # Get band info
        band_info = WORLDCLIM_BANDS[band_name]
        
        # Apply scale factor to convert temperature values
        scaled_data = band_data * band_info['scale_factor']
        
        # Create visualization
        im = ax.imshow(scaled_data, cmap=band_info['cmap'], aspect='auto')
        
        # Set title with statistics
        mean_val = np.nanmean(scaled_data)
        std_val = np.nanstd(scaled_data)
        ax.set_title(f'{band_info["description"]}\nMean: {mean_val:.1f} {band_info["unit"]}\nStd: {std_val:.1f}', 
                    fontsize=9, fontweight='bold')
        
        # Add colorbar
        cbar = plt.colorbar(im, ax=ax, shrink=0.8)
        cbar.set_label(band_info['unit'], rotation=270, labelpad=10, fontsize=8)
        
        # Remove axis labels for cleaner look
        ax.set_xticks([])
        ax.set_yticks([])
    
    # Hide the last empty subplot
    axes_flat[-1].set_visible(False)
    
    plt.tight_layout()
    
    # Save the plot
    output_file = output_dir / "worldclim_bio_overview.png"
    plt.savefig(output_file, dpi=300, bbox_inches='tight')
    print(f"   üíæ Saved: {output_file.name}")
    
    plt.close()  # Close to free memory

def create_temperature_precipitation_comparison(data_info):
    """Create focused comparison of temperature and precipitation variables"""
    if data_info is None:
        return
    
    print("üå°Ô∏è Creating temperature and precipitation comparison...")
    
    data = data_info['data']
    band_names = data_info['band_names']
    
    # Separate temperature and precipitation bands
    temp_bands = ['bio01', 'bio05', 'bio06', 'bio10', 'bio11']  # Key temperature variables
    precip_bands = ['bio12', 'bio13', 'bio14', 'bio16', 'bio17']  # Key precipitation variables
    
    # Create figure with two rows
    fig, axes = plt.subplots(2, 5, figsize=(20, 8))
    fig.suptitle('Key Temperature and Precipitation Variables - South America', 
                fontsize=16, fontweight='bold')
    
    # Temperature variables (top row)
    for idx, band_name in enumerate(temp_bands):
        ax = axes[0, idx]
        band_idx = band_names.index(band_name)
        band_data = data[band_idx]
        band_info = WORLDCLIM_BANDS[band_name]
        
        # Apply scale factor to convert temperature values
        scaled_data = band_data * band_info['scale_factor']
        
        im = ax.imshow(scaled_data, cmap=band_info['cmap'], aspect='auto')
        ax.set_title(f'{band_info["description"]}\nMean: {np.nanmean(scaled_data):.1f} {band_info["unit"]}', 
                    fontsize=10, fontweight='bold')
        
        cbar = plt.colorbar(im, ax=ax, shrink=0.8)
        cbar.set_label(band_info['unit'], rotation=270, labelpad=10, fontsize=8)
        ax.set_xticks([])
        ax.set_yticks([])
    
    # Precipitation variables (bottom row)
    for idx, band_name in enumerate(precip_bands):
        ax = axes[1, idx]
        band_idx = band_names.index(band_name)
        band_data = data[band_idx]
        band_info = WORLDCLIM_BANDS[band_name]
        
        # Apply scale factor to convert temperature values
        scaled_data = band_data * band_info['scale_factor']
        
        im = ax.imshow(scaled_data, cmap=band_info['cmap'], aspect='auto')
        ax.set_title(f'{band_info["description"]}\nMean: {np.nanmean(scaled_data):.1f} {band_info["unit"]}', 
                    fontsize=10, fontweight='bold')
        
        cbar = plt.colorbar(im, ax=ax, shrink=0.8)
        cbar.set_label(band_info['unit'], rotation=270, labelpad=10, fontsize=8)
        ax.set_xticks([])
        ax.set_yticks([])
    
    plt.tight_layout()
    
    # Save the plot
    output_file = output_dir / "worldclim_temp_precip_comparison.png"
    plt.savefig(output_file, dpi=300, bbox_inches='tight')
    print(f"   üíæ Saved: {output_file.name}")
    
    plt.close()

def create_statistics_summary(data_info):
    """Create summary statistics for all variables"""
    if data_info is None:
        return
    
    print("üìä Creating statistics summary...")
    
    data = data_info['data']
    band_names = data_info['band_names']
    
    # Collect statistics
    stats_data = []
    for band_idx, band_name in enumerate(band_names):
        band_data = data[band_idx]
        band_info = WORLDCLIM_BANDS[band_name]
        
        # Apply scale factor to convert temperature values
        scaled_data = band_data * band_info['scale_factor']
        
        stats = {
            'band': band_name,
            'description': band_info['description'],
            'unit': band_info['unit'],
            'mean': np.nanmean(scaled_data),
            'std': np.nanstd(scaled_data),
            'min': np.nanmin(scaled_data),
            'max': np.nanmax(scaled_data),
            'median': np.nanmedian(scaled_data)
        }
        stats_data.append(stats)
    
    # Create figure
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))
    fig.suptitle('WorldClim BIO Statistics Summary - South America', 
                fontsize=16, fontweight='bold')
    
    # 1. Mean values by variable type
    ax1 = axes[0, 0]
    temp_means = [s['mean'] for s in stats_data if 'temperature' in s['description'].lower() or 'temp' in s['description'].lower()]
    temp_names = [s['description'][:20] + '...' if len(s['description']) > 20 else s['description'] 
                  for s in stats_data if 'temperature' in s['description'].lower() or 'temp' in s['description'].lower()]
    
    precip_means = [s['mean'] for s in stats_data if 'precipitation' in s['description'].lower() or 'precip' in s['description'].lower()]
    precip_names = [s['description'][:20] + '...' if len(s['description']) > 20 else s['description'] 
                    for s in stats_data if 'precipitation' in s['description'].lower() or 'precip' in s['description'].lower()]
    
    x_pos = np.arange(len(temp_names))
    ax1.bar(x_pos, temp_means, alpha=0.7, color='red')
    ax1.set_title('Mean Temperature Variables', fontweight='bold')
    ax1.set_ylabel('Temperature (¬∞C √ó 10)')
    ax1.set_xticks(x_pos)
    ax1.set_xticklabels(temp_names, rotation=45, ha='right')
    
    # 2. Precipitation means
    ax2 = axes[0, 1]
    x_pos2 = np.arange(len(precip_names))
    ax2.bar(x_pos2, precip_means, alpha=0.7, color='blue')
    ax2.set_title('Mean Precipitation Variables', fontweight='bold')
    ax2.set_ylabel('Precipitation (mm)')
    ax2.set_xticks(x_pos2)
    ax2.set_xticklabels(precip_names, rotation=45, ha='right')
    
    # 3. Range (max-min) comparison
    ax3 = axes[1, 0]
    ranges = [s['max'] - s['min'] for s in stats_data]
    range_names = [s['band'] for s in stats_data]
    
    x_pos3 = np.arange(len(range_names))
    ax3.bar(x_pos3, ranges, alpha=0.7, color='green')
    ax3.set_title('Value Range by Variable', fontweight='bold')
    ax3.set_ylabel('Range (max - min)')
    ax3.set_xticks(x_pos3)
    ax3.set_xticklabels(range_names, rotation=45, ha='right')
    
    # 4. Coefficient of variation (std/mean)
    ax4 = axes[1, 1]
    cv_values = [s['std'] / s['mean'] if s['mean'] != 0 else 0 for s in stats_data]
    cv_names = [s['band'] for s in stats_data]
    
    x_pos4 = np.arange(len(cv_names))
    ax4.bar(x_pos4, cv_values, alpha=0.7, color='purple')
    ax4.set_title('Coefficient of Variation (CV)', fontweight='bold')
    ax4.set_ylabel('CV (std/mean)')
    ax4.set_xticks(x_pos4)
    ax4.set_xticklabels(cv_names, rotation=45, ha='right')
    
    plt.tight_layout()
    
    # Save the plot
    output_file = output_dir / "worldclim_statistics_summary.png"
    plt.savefig(output_file, dpi=300, bbox_inches='tight')
    print(f"   üíæ Saved: {output_file.name}")
    
    plt.close()

def main():
    """Main visualization function"""
    print("üåç WorldClim BIO Visualization - South America (1960-1991)")
    print("=" * 70)
    
    # Load data
    data_info = load_worldclim_data()
    
    if data_info is None:
        print("‚ùå Failed to load data. Exiting.")
        return
    
    # Create visualizations
    print("\nüé® Creating visualizations...")
    
    # 1. Overview of all variables
    create_overview_visualization(data_info)
    
    # 2. Temperature and precipitation comparison
    create_temperature_precipitation_comparison(data_info)
    
    # 3. Statistics summary
    create_statistics_summary(data_info)
    
    # Summary
    print("\n" + "=" * 70)
    print("üìã VISUALIZATION SUMMARY")
    print("=" * 70)
    
    data = data_info['data']
    print(f"Data shape: {data.shape}")
    print(f"Number of bands: {data.shape[0]}")
    print(f"Spatial dimensions: {data.shape[1]} x {data.shape[2]}")
    print(f"Total pixels: {data.shape[1] * data.shape[2]:,}")
    print(f"Valid pixels: {np.sum(~np.isnan(data)):,}")
    
    print(f"\nBioclimatic variables:")
    for band_name, band_info in WORLDCLIM_BANDS.items():
        print(f"  - {band_name}: {band_info['description']} ({band_info['unit']})")
    
    print(f"\nüíæ Output files saved to: {output_dir}")
    print("   - worldclim_bio_overview.png")
    print("   - worldclim_temp_precip_comparison.png")
    print("   - worldclim_statistics_summary.png")
    
    print("\n‚úÖ Visualization complete! üéâ")

if __name__ == "__main__":
    main()
