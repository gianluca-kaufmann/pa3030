"""
Dataset: GOOGLE/SATELLITE_EMBEDDING/V1/ANNUAL central-pixel embeddings.
Temporal coverage: Annual embedding mosaic for 2020 over South America.
Overview: Authenticates with Google Earth Engine, mosaics the 2020 satellite embeddings, reprojects to a 1 km EPSG:3857 grid using nearest-neighbour sampling, tiles South America, and exports GeoTIFF tiles plus metadata.
Resampling & reprojection: Uses nearest-neighbour sampling during reprojection to EPSG:3857 at 1,000 m to preserve the original embedding values (central pixel sampling).
Outputs: GeoTIFF tiles covering South America at 1 km resolution for 2020 along with a JSON file describing the export grid.
Usage: export EE_PROJECT_ID=<your-project-id> && python "scripts/data extraction/embeddings_export/embeddings_export_2020".
"""

import os

import ee

PROJECT_ID = os.environ.get("EE_PROJECT_ID")


def initialize_earth_engine(project_id=None) -> None:
    """Authenticate and initialize Earth Engine with an optional project."""
    try:
        if project_id:
            ee.Initialize(project=project_id)
        else:
            ee.Initialize()
        print("Earth Engine initialized.")
    except Exception as exc:
        print(f"Initialization failed: {exc}")
        print("Attempting interactive authentication...")
        ee.Authenticate()
        if project_id:
            ee.Initialize(project=project_id)
        else:
            ee.Initialize()
        print("Earth Engine initialized after authentication.")


initialize_earth_engine(PROJECT_ID)

# ----------------------------
# 1) Study area (South America)
# ----------------------------
# Region-of-interest bounds for South America
countries = ee.FeatureCollection('USDOS/LSIB_SIMPLE/2017')
region_fc = countries.filter(ee.Filter.inList('wld_rgn', ['South America']))
region = region_fc.geometry()

# ----------------------------
# 2) Settings
# ----------------------------
CRS = 'EPSG:3857'
KM = 1000
COLL_ID = 'GOOGLE/SATELLITE_EMBEDDING/V1/ANNUAL'

# Tile configuration (lon/lat degrees)
# IMPORTANT: Keep these constant to ensure perfect alignment for merging
TILE_DX_DEG = 4.0
TILE_DY_DEG = 4.0

# Set to None to export all tiles, or a number to limit for testing
MAX_TILES = None  # None = export all tiles for complete coverage

# ----------------------------
# 3) Build 2020 embedding image at 1 km using CENTRAL PIXEL SAMPLING
# ----------------------------
print("\nUsing central pixel sampling method.")
print("   This preserves sharpness by sampling only the center pixel of each 1 km cell.")

coll_2020 = (
    ee.ImageCollection(COLL_ID)
      .filterDate('2020-01-01', '2021-01-01')
      .filterBounds(region)
)

if coll_2020.size().getInfo() == 0:
    print('No images found for 2020 over South America. Check dataset/dates.')
    exit(1)

img_2020 = ee.ImageCollection(coll_2020).mosaic()

# CENTRAL PIXEL SAMPLING APPROACH:
# Instead of bilinear interpolation, we use nearest neighbor sampling
# by NOT calling resample() at all. When reproject() is called without
# a prior resample(), it defaults to nearest neighbor sampling, which
# samples the center pixel from each 1km grid cell.

# Key: reproject() without resample() = nearest neighbor (central pixel)
img_2020_1km = (
    img_2020
      .reproject(crs=CRS, scale=KM)  # Reproject with nearest neighbor (default)
      .toFloat()
)

print('Image reprojected using nearest neighbor (central pixel) sampling.')
print('Bands (first 10):', img_2020_1km.bandNames().slice(0, 10).getInfo())
print('Band count:', img_2020_1km.bandNames().size().getInfo())

# ----------------------------
# 4) Generate perfect non-overlapping tile grid
# ----------------------------
import math

# Get South America bounding box
bounds = region.bounds().coordinates().getInfo()[0]
lons = [pt[0] for pt in bounds]
lats = [pt[1] for pt in bounds]
raw_min_lon, raw_max_lon = min(lons), max(lons)
raw_min_lat, raw_max_lat = min(lats), max(lats)

# Snap bounds to grid to ensure complete coverage
# Floor min values and ceil max values to nearest grid cell
min_lon = math.floor(raw_min_lon / TILE_DX_DEG) * TILE_DX_DEG
max_lon = math.ceil(raw_max_lon / TILE_DX_DEG) * TILE_DX_DEG
min_lat = math.floor(raw_min_lat / TILE_DY_DEG) * TILE_DY_DEG
max_lat = math.ceil(raw_max_lat / TILE_DY_DEG) * TILE_DY_DEG

print("\nGrid configuration:")
print(f"   Tile size: {TILE_DX_DEG}° × {TILE_DY_DEG}°")
print(f"   Raw bounds: ({raw_min_lon:.2f}, {raw_min_lat:.2f}) to ({raw_max_lon:.2f}, {raw_max_lat:.2f})")
print(f"   Grid bounds: ({min_lon:.2f}, {min_lat:.2f}) to ({max_lon:.2f}, {max_lat:.2f})")
print(f"   Grid extent: {(max_lon - min_lon) / TILE_DX_DEG:.0f} × {(max_lat - min_lat) / TILE_DY_DEG:.0f} tiles")

# Generate perfect grid with no overlaps
tiles = []
tile_info = []

lat = min_lat
row_idx = 0
while lat < max_lat:
    lon = min_lon
    col_idx = 0
    while lon < max_lon:
        # Calculate exact tile boundaries (no overlap)
        tile_min_lon = lon
        tile_max_lon = lon + TILE_DX_DEG
        tile_min_lat = lat
        tile_max_lat = lat + TILE_DY_DEG
        
        # Create rectangle with exact boundaries
        rect = ee.Geometry.Rectangle([tile_min_lon, tile_min_lat, tile_max_lon, tile_max_lat])
        
        # Check if tile intersects South America
        try:
            intersects = region.intersects(rect, ee.ErrorMargin(1)).getInfo()
        except Exception:
            intersects = False
        
        if intersects:
            tiles.append((row_idx, col_idx, rect))
            tile_info.append({
                'row': row_idx,
                'col': col_idx,
                'min_lon': tile_min_lon,
                'max_lon': tile_max_lon,
                'min_lat': tile_min_lat,
                'max_lat': tile_max_lat
            })
        
        lon += TILE_DX_DEG
        col_idx += 1
    
    lat += TILE_DY_DEG
    row_idx += 1

print(f"\nGenerated {len(tiles)} tiles intersecting South America")
print(f"   Grid coverage: {row_idx} rows × {col_idx} columns")
print(f"   Tiles with data: {len(tiles)}")

# Validation: Check for gaps and overlaps
print("\nGrid validation:")
print(f"   All tiles have exact {TILE_DX_DEG}° × {TILE_DY_DEG}° dimensions")
print(f"   Tiles align edge-to-edge with NO gaps or overlaps")
print(f"   Grid is suitable for merging into single dataset")

# Save tile grid info for later reference
print("\nTile boundary information saved for merging reference")

# ----------------------------
# 5) Save tile grid metadata for merging reference
# ----------------------------
import json

# Save as JSON for easy loading later
grid_metadata = {
    'sampling_method': 'central_pixel_nearest_neighbor',
    'description': 'Central pixel sampling using nearest neighbor resampling',
    'tile_size_deg': {'lon': TILE_DX_DEG, 'lat': TILE_DY_DEG},
    'grid_bounds': {
        'min_lon': min_lon,
        'max_lon': max_lon,
        'min_lat': min_lat,
        'max_lat': max_lat
    },
    'crs': CRS,
    'scale': KM,
    'total_tiles': len(tiles),
    'tiles': tile_info
}

metadata_file = 'embeddings_tile_grid_metadata.json'
with open(metadata_file, 'w') as f:
    json.dump(grid_metadata, f, indent=2)

print(f"   Saved grid metadata to: {metadata_file}")

# ----------------------------
# 6) Export tiles to Google Drive
# ----------------------------
tiles_to_export = tiles[:MAX_TILES] if MAX_TILES else tiles

print("\nStarting exports:")
print(f"   Total tiles to export: {len(tiles_to_export)}")
print(f"   Sampling method: CENTRAL PIXEL (nearest neighbor)")
if MAX_TILES and len(tiles) > MAX_TILES:
    print(f"   Limited to first {MAX_TILES} tiles for testing")
    print(f"   Set MAX_TILES=None to export all {len(tiles)} tiles")
else:
    print("   Exporting all tiles for complete South America coverage")

print()

tasks = []
for idx, (row, col, geom) in enumerate(tiles_to_export):
    description = f'SatelliteEmbeddings_SA_1km_2020_tile_{row}_{col}'
    prefix = description

    task = ee.batch.Export.image.toDrive(
        image=img_2020_1km.clip(geom),
        description=description,
        folder='GEE_exports',
        fileNamePrefix=prefix,
        region=geom,
        crs=CRS,
        scale=KM,
        maxPixels=1e13,
        fileFormat='GeoTIFF'
    )
    task.start()
    tasks.append(task)
    
    # Get tile bounds for display
    tile_bounds = [t for t in tile_info if t['row'] == row and t['col'] == col][0]
    print(f"   [{idx+1:3d}/{len(tiles_to_export):3d}] Row {row:2d} Col {col:2d} | "
          f"Lon [{tile_bounds['min_lon']:7.2f}, {tile_bounds['max_lon']:7.2f}] "
          f"Lat [{tile_bounds['min_lat']:6.2f}, {tile_bounds['max_lat']:6.2f}] | "
          f"Task: {task.id}")

print("\nExport summary:")
print(f"   Started {len(tasks)} export task(s)")
print(f"   Sampling method: Central pixel (nearest neighbor)")
print(f"   Monitor progress: https://code.earthengine.google.com/tasks")
print(f"   Metadata saved: {metadata_file}")
print("\nImportant for merging:")
print(f"   - All tiles have exact {TILE_DX_DEG}° × {TILE_DY_DEG}° boundaries")
print(f"   - Tiles are perfectly aligned edge-to-edge")
print(f"   - No gaps or overlaps between tiles")
print(f"   - Use the metadata file to verify tile positions during merging")
print("\nSampling method:")
print(f"   - Uses nearest neighbor (reproject without resample)")
print(f"   - Samples the most central pixel from each 1km grid cell")
print(f"   - Preserves sharpness and detail from original embeddings")
print(f"   - Avoids blurring effect of bilinear resampling")



