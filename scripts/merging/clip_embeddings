#!/usr/bin/env python3
"""
Clip satellite embeddings to match coastline of reference datasets.

This script clips the merged embeddings file to the exact land mask used by
other datasets (GPW), ensuring clean coastlines without chunky artifacts.
Uses memory-efficient chunked processing for large files.
"""

import sys
import time
from pathlib import Path
from typing import Tuple

import numpy as np
import rasterio
from rasterio.windows import Window


# Paths
DATA_ROOT = Path("/Users/gianluca/Desktop/Master's Thesis/code/data")
EMBEDDINGS_DIR = DATA_ROOT / "ready" / "embeddings"
GPW_DIR = DATA_ROOT / "ready" / "GPW"

# Input files
EMBEDDINGS_FILE = EMBEDDINGS_DIR / "SatelliteEmbeddings_SA_1km_2020_merged.tif"
GPW_REFERENCE = GPW_DIR / "GPW_population_density_SA_1km_2020.tif"

# Output file
OUTPUT_FILE = EMBEDDINGS_DIR / "SatelliteEmbeddings_SA_1km_2020_clipped.tif"

# Processing settings
CHUNK_SIZE = 1000  # Process 1000 rows at a time to manage memory


def log_progress(message: str, start_time: float = None):
    """Log progress with optional timing."""
    if start_time:
        elapsed = time.time() - start_time
        print(f"‚è±Ô∏è  {message} ({elapsed:.1f}s)")
    else:
        print(f"üìä {message}")


def validate_alignment(emb_path: Path, ref_path: Path) -> Tuple[bool, str]:
    """Validate that files are aligned."""
    with rasterio.open(emb_path) as emb, rasterio.open(ref_path) as ref:
        if emb.crs != ref.crs:
            return False, f"CRS mismatch: {emb.crs} vs {ref.crs}"
        if emb.transform != ref.transform:
            return False, f"Transform mismatch"
        if emb.shape != ref.shape:
            return False, f"Shape mismatch: {emb.shape} vs {ref.shape}"
    return True, "Files are aligned"


def create_land_mask(ref_path: Path, chunk_size: int = 1000) -> np.ndarray:
    """
    Create land mask from reference file using chunked processing.
    
    Args:
        ref_path: Path to reference file (GPW)
        chunk_size: Number of rows to process at once
    Returns:
        Boolean mask where True = land, False = ocean/nodata
    """
    log_progress("Creating land mask from GPW reference...")
    start_time = time.time()
    
    with rasterio.open(ref_path) as ref:
        height, width = ref.shape
        land_mask = np.zeros((height, width), dtype=bool)
        
        # Process in chunks
        num_chunks = int(np.ceil(height / chunk_size))
        
        for i in range(num_chunks):
            row_start = i * chunk_size
            row_end = min((i + 1) * chunk_size, height)
            chunk_height = row_end - row_start
            
            # Read chunk
            window = Window(0, row_start, width, chunk_height)
            chunk_data = ref.read(1, window=window)
            
            # Land is where we have valid (non-NaN) data
            # Note: GPW uses NaN for ocean, any finite value indicates land
            land_chunk = np.isfinite(chunk_data)
            land_mask[row_start:row_end, :] = land_chunk
            
            if (i + 1) % 5 == 0 or (i + 1) == num_chunks:
                progress = (i + 1) / num_chunks * 100
                print(f"   Processing chunk {i + 1}/{num_chunks} ({progress:.1f}%)")
    
    land_pixels = land_mask.sum()
    total_pixels = land_mask.size
    log_progress(f"Land mask created: {land_pixels:,} land pixels ({land_pixels/total_pixels*100:.2f}%)", 
                 start_time)
    
    return land_mask


def clip_embeddings_chunked(emb_path: Path, land_mask: np.ndarray, 
                            output_path: Path, chunk_size: int = 1000) -> None:
    """
    Clip embeddings to land mask using chunked processing.
    
    Args:
        emb_path: Path to embeddings file
        land_mask: Boolean land mask
        output_path: Path for output file
        chunk_size: Number of rows to process at once
    """
    log_progress("Clipping embeddings using land mask...")
    start_time = time.time()
    
    with rasterio.open(emb_path) as src:
        # Prepare output profile
        profile = src.profile.copy()
        profile.update({
            'nodata': 0,  # Use 0 for ocean/nodata areas
            'compress': 'lzw',
            'tiled': True,
            'blockxsize': 512,
            'blockysize': 512,
            'BIGTIFF': 'YES',
        })
        
        height, width = src.shape
        num_bands = src.count
        num_chunks = int(np.ceil(height / chunk_size))
        
        log_progress(f"Processing {num_bands} bands, {height} rows in {num_chunks} chunks...")
        
        with rasterio.open(output_path, 'w', **profile) as dst:
            for i in range(num_chunks):
                row_start = i * chunk_size
                row_end = min((i + 1) * chunk_size, height)
                chunk_height = row_end - row_start
                
                # Read chunk for all bands
                window = Window(0, row_start, width, chunk_height)
                chunk_data = src.read(window=window)  # (bands, rows, cols)
                
                # Get land mask for this chunk
                mask_chunk = land_mask[row_start:row_end, :]
                
                # Apply mask: set ocean pixels to 0 across all bands
                # Use broadcasting: mask_chunk is (rows, cols), chunk_data is (bands, rows, cols)
                ocean_mask = ~mask_chunk  # True where ocean
                chunk_data[:, ocean_mask] = 0
                
                # Also replace any remaining NaN values with 0
                chunk_data[np.isnan(chunk_data)] = 0
                
                # Write clipped chunk
                dst.write(chunk_data, window=window)
                
                if (i + 1) % 5 == 0 or (i + 1) == num_chunks:
                    progress = (i + 1) / num_chunks * 100
                    elapsed = time.time() - start_time
                    est_total = elapsed / (i + 1) * num_chunks
                    est_remaining = est_total - elapsed
                    print(f"   Chunk {i + 1}/{num_chunks} ({progress:.1f}%) - "
                          f"Est. remaining: {est_remaining:.0f}s")
    
    log_progress("Clipping complete", start_time)


def print_statistics(input_path: Path, output_path: Path, land_mask: np.ndarray) -> None:
    """Print statistics comparing input and output files."""
    print("\n" + "=" * 80)
    print("CLIPPING STATISTICS")
    print("=" * 80)
    
    with rasterio.open(input_path) as src_in, rasterio.open(output_path) as src_out:
        print(f"\nüìÅ INPUT FILE:")
        print(f"   File: {input_path.name}")
        print(f"   Size: {input_path.stat().st_size / (1024**3):.2f} GB")
        print(f"   Dimensions: {src_in.shape[1]} x {src_in.shape[0]} pixels")
        print(f"   Bands: {src_in.count}")
        
        print(f"\nüìÅ OUTPUT FILE:")
        print(f"   File: {output_path.name}")
        print(f"   Size: {output_path.stat().st_size / (1024**3):.2f} GB")
        print(f"   Dimensions: {src_out.shape[1]} x {src_out.shape[0]} pixels")
        print(f"   Bands: {src_out.count}")
        
        # Sample data from first band to check clipping
        print(f"\nüî¨ DATA QUALITY CHECK (Band 1):")
        
        # Read first band
        in_band1 = src_in.read(1)
        out_band1 = src_out.read(1)
        
        # Count valid pixels
        in_valid = np.sum(~np.isnan(in_band1))
        out_valid = np.sum(out_band1 != 0)
        land_pixels = land_mask.sum()
        
        print(f"   Input valid pixels:  {in_valid:,}")
        print(f"   Output valid pixels: {out_valid:,}")
        print(f"   Land mask pixels:    {land_pixels:,}")
        print(f"   Match: {'‚úÖ' if out_valid == land_pixels else '‚ö†Ô∏è'}")
        
        # Check ocean pixels are properly set to 0
        ocean_pixels = np.sum(out_band1[~land_mask] != 0)
        print(f"\n   Ocean pixels set to 0: {'‚úÖ' if ocean_pixels == 0 else f'‚ö†Ô∏è {ocean_pixels:,} non-zero'}")
        
        # Data range (only non-zero land values)
        land_values = out_band1[land_mask & (out_band1 != 0)]
        if len(land_values) > 0:
            print(f"\n   Land data range: [{np.min(land_values):.4f}, {np.max(land_values):.4f}]")
            print(f"   Land data mean: {np.mean(land_values):.4f}")
        
        # Check for any remaining NaN values
        nan_count = np.sum(np.isnan(out_band1))
        if nan_count > 0:
            print(f"\n   ‚ö†Ô∏è  Remaining NaN values: {nan_count:,}")
        else:
            print(f"\n   ‚úÖ No NaN values (all replaced with 0)")


def main():
    """Main clipping function."""
    total_start = time.time()
    
    print("=" * 80)
    print("SATELLITE EMBEDDINGS COASTLINE CLIPPING")
    print("=" * 80)
    print()
    
    # Validate input files
    if not EMBEDDINGS_FILE.exists():
        print(f"‚ùå Embeddings file not found: {EMBEDDINGS_FILE}")
        sys.exit(1)
    
    if not GPW_REFERENCE.exists():
        print(f"‚ùå GPW reference file not found: {GPW_REFERENCE}")
        sys.exit(1)
    
    log_progress(f"Input: {EMBEDDINGS_FILE.name}")
    log_progress(f"Reference: {GPW_REFERENCE.name}")
    log_progress(f"Output: {OUTPUT_FILE.name}")
    print()
    
    # Validate alignment
    log_progress("Validating file alignment...")
    aligned, message = validate_alignment(EMBEDDINGS_FILE, GPW_REFERENCE)
    if not aligned:
        print(f"‚ùå Files are not aligned: {message}")
        sys.exit(1)
    log_progress(f"‚úÖ {message}")
    print()
    
    # Create land mask
    land_mask = create_land_mask(GPW_REFERENCE, chunk_size=CHUNK_SIZE)
    print()
    
    # Clip embeddings
    clip_embeddings_chunked(EMBEDDINGS_FILE, land_mask, OUTPUT_FILE, chunk_size=CHUNK_SIZE)
    print()
    
    # Print statistics
    print_statistics(EMBEDDINGS_FILE, OUTPUT_FILE, land_mask)
    
    # Summary
    total_time = time.time() - total_start
    print("\n" + "=" * 80)
    print(f"‚úÖ Clipping completed successfully in {total_time/60:.1f} minutes")
    print(f"Output: {OUTPUT_FILE}")
    print("=" * 80)


if __name__ == "__main__":
    main()
