#!/usr/bin/env python3
"""
Simplified 2012 Dataset Merge Script
===================================

Clean approach:
1. Load template raster as spatial backbone
2. Merge with other raster files
3. For each shapefile: read, clean, reproject, rasterize, clip to template extent
4. Stack all masks onto template raster

Dependencies: geopandas, rasterio, numpy, matplotlib
"""

import numpy as np
import geopandas as gpd
import rasterio
from rasterio.features import rasterize
from rasterio.warp import reproject, Resampling
import os
from pathlib import Path

# ==========
# Configuration
# ==========

DATA_DIR = "/Users/gianluca/Desktop/Master's Thesis/code/data"

# Template raster (defines CRS, grid, extent)
TEMPLATE_TIF = f"{DATA_DIR}/gpw_2012.tif"

# Additional raster files to merge
RASTER_FILES = [
    f"{DATA_DIR}/wdpa_2012.tif",      # Protected areas (convert to binary)
    f"{DATA_DIR}/viirs_2012.tif",     # Night lights (continuous)
]

# Shapefiles to rasterize
SHAPEFILES = [
    (f"{DATA_DIR}/climate_stabilisation_areas/Climate_Stabilization_Area.shp", "climate_stabilization", False),
    (f"{DATA_DIR}/high_biodiversity_areas/High biodiversity areas .shp", "high_biodiversity", False),
    (f"{DATA_DIR}/intact_wilderness_areas/Intact wilderness areas.shp", "intact_wilderness", False),
    (f"{DATA_DIR}/potential_wildlife_corridors/Potential wildlife corridors .shp", "wildlife_corridors", False),
    (f"{DATA_DIR}/terrestrial_ecoregions/Terrestrial_ecoregions.shp", "terrestrial_ecoregions", True),  # Use ECO_ID
]

# Output
OUTPUT_STACK = f"{DATA_DIR}/south_america_2012_complete_stack.tif"
OUTPUT_MASKS_DIR = f"{DATA_DIR}/output_masks"
OUTPUT_VISUALIZATION = "/Users/gianluca/Desktop/Master's Thesis/code/outputs/Figures/2012_complete_stack_visualization.png"

# ==========
# Helper Functions
# ==========

def load_template_info(template_path):
    """Load template raster information"""
    with rasterio.open(template_path) as src:
        return {
            'crs': src.crs,
            'transform': src.transform,
            'width': src.width,
            'height': src.height,
            'profile': src.profile.copy(),
            'nodata': src.nodata
        }

def reproject_raster_to_template(raster_path, template_info, convert_to_binary=False):
    """Reproject raster to match template grid"""
    with rasterio.open(raster_path) as src:
        src_data = src.read(1).astype("float32")
        src_nodata = src.nodata
        src_crs = src.crs
        src_transform = src.transform
    
    # Reproject
    dest = np.full((template_info['height'], template_info['width']), np.nan, dtype="float32")
    reproject(
        source=src_data,
        destination=dest,
        src_transform=src_transform,
        src_crs=src_crs,
        src_nodata=src_nodata,
        dst_transform=template_info['transform'],
        dst_crs=template_info['crs'],
        dst_nodata=np.nan,
        resampling=Resampling.bilinear,
    )
    
    # Convert to binary if requested
    if convert_to_binary:
        dest = np.where(np.isfinite(dest) & (dest > 0), 1, 0).astype("float32")
    
    return dest

def load_and_clean_shapefile(shp_path, target_crs):
    """Load shapefile, clean geometries, reproject to target CRS"""
    gdf = gpd.read_file(shp_path)
    
    # Clean geometries
    gdf = gdf[~gdf.geometry.is_empty & gdf.geometry.notnull()].copy()
    if gdf.empty:
        return gdf
    
    # Fix invalid geometries
    gdf.geometry = gdf.geometry.buffer(0)
    gdf = gdf[~gdf.geometry.is_empty & gdf.geometry.notnull()].copy()
    
    # Reproject to target CRS
    if gdf.crs != target_crs:
        gdf = gdf.to_crs(target_crs)
    
    return gdf

def rasterize_shapefile(gdf, template_info, use_eco_id=False):
    """Rasterize shapefile to template grid"""
    if gdf.empty:
        return np.zeros((template_info['height'], template_info['width']), dtype="float32")
    
    if use_eco_id and 'ECO_ID' in gdf.columns:
        # Use ECO_ID for ecoregions
        shapes = ((geom, val) for geom, val in zip(gdf.geometry, gdf['ECO_ID']))
        dtype = "float32"
    else:
        # Binary rasterization
        shapes = ((geom, 1) for geom in gdf.geometry)
        dtype = "float32"
    
    arr = rasterize(
        shapes=shapes,
        out_shape=(template_info['height'], template_info['width']),
        transform=template_info['transform'],
        fill=0,
        dtype=dtype,
        all_touched=True
    )
    
    return arr.astype("float32")

def clip_to_template_extent(arr, template_path):
    """Clip array to template's valid extent"""
    with rasterio.open(template_path) as src:
        template_band = src.read(1)
        valid_mask = np.isfinite(template_band)
    
    # Clip to template extent
    clipped = np.where(valid_mask, arr, 0).astype("float32")
    return clipped

def create_visualization(stacked_data, band_names, output_path):
    """Create visualization of the merged dataset"""
    try:
        import matplotlib.pyplot as plt
        
        n_bands = stacked_data.shape[0]
        n_cols = 3
        n_rows = (n_bands + n_cols - 1) // n_cols
        
        fig, axes = plt.subplots(n_rows, n_cols, figsize=(15, 5*n_rows))
        fig.suptitle('South America 2012 Complete Dataset Stack', fontsize=16)
        
        # Flatten axes
        if n_rows == 1:
            axes = [axes] if n_cols == 1 else axes
        else:
            axes = axes.flatten()
        
        for i in range(n_bands):
            ax = axes[i]
            band_data = stacked_data[i]
            
            # Visualization based on band type
            if i == 1:  # Protected areas (binary)
                colors = ['white', 'darkgreen']
                cmap = plt.cm.colors.ListedColormap(colors)
                im = ax.imshow(band_data, cmap=cmap, vmin=0, vmax=1)
            elif i == 7:  # Terrestrial ecoregions (integer with plasma)
                unique_vals = np.unique(band_data[band_data > 0])
                if len(unique_vals) > 0:
                    im = ax.imshow(band_data, cmap='plasma', vmin=unique_vals.min(), vmax=unique_vals.max())
                else:
                    im = ax.imshow(band_data, cmap='plasma')
            elif i >= 3:  # Other shapefile-derived bands (binary)
                colors = ['white', 'darkgreen']
                cmap = plt.cm.colors.ListedColormap(colors)
                im = ax.imshow(band_data, cmap=cmap, vmin=0, vmax=1)
            else:  # Continuous raster data
                valid_data = band_data[~np.isnan(band_data)]
                if len(valid_data) > 0:
                    p2, p98 = np.percentile(valid_data, [2, 98])
                    im = ax.imshow(band_data, cmap='viridis', vmin=p2, vmax=p98)
                else:
                    im = ax.imshow(band_data, cmap='viridis')
            
            ax.set_title(f'Band {i+1}: {band_names[i]}')
            ax.set_xlabel('Longitude')
            ax.set_ylabel('Latitude')
            ax.set_aspect('equal')
            plt.colorbar(im, ax=ax, shrink=0.6)
        
        # Remove empty subplots
        for i in range(n_bands, len(axes)):
            axes[i].remove()
        
        plt.tight_layout()
        plt.savefig(output_path, dpi=300, bbox_inches='tight')
        plt.close()
        print(f"Visualization saved → {output_path}")
        
    except Exception as e:
        print(f"Visualization failed: {e}")

# ==========
# Main Processing
# ==========

def main():
    print("=" * 60)
    print("Simplified 2012 Dataset Merge Script")
    print("=" * 60)
    
    # Check template file
    if not os.path.exists(TEMPLATE_TIF):
        print(f"❌ Template file not found: {TEMPLATE_TIF}")
        return
    
    # Create output directory
    Path(OUTPUT_MASKS_DIR).mkdir(parents=True, exist_ok=True)
    
    # Load template info
    print(f"\nLoading template: {os.path.basename(TEMPLATE_TIF)}")
    template_info = load_template_info(TEMPLATE_TIF)
    print(f"Template CRS: {template_info['crs']}")
    print(f"Template dimensions: {template_info['width']} x {template_info['height']}")
    
    # Load template data
    with rasterio.open(TEMPLATE_TIF) as src:
        template_data = src.read(1).astype("float32")
    
    # Start with template as first band
    all_bands = [template_data]
    band_names = ["population"]
    
    # Process additional raster files
    print(f"\nProcessing raster files...")
    for raster_path in RASTER_FILES:
        if not os.path.exists(raster_path):
            print(f"⚠️  Skipping missing file: {os.path.basename(raster_path)}")
            continue
        
        print(f"  Processing: {os.path.basename(raster_path)}")
        
        # Convert protected areas to binary
        convert_to_binary = "wdpa" in raster_path.lower()
        
        # Reproject to template
        reprojected = reproject_raster_to_template(raster_path, template_info, convert_to_binary)
        
        # Clip to template extent
        clipped = clip_to_template_extent(reprojected, TEMPLATE_TIF)
        
        all_bands.append(clipped)
        
        if convert_to_binary:
            band_names.append("protected_areas")
            print(f"    ✓ Added binary protected areas band")
        else:
            band_names.append("night_lights")
            print(f"    ✓ Added night lights band")
    
    # Process shapefiles
    print(f"\nProcessing shapefiles...")
    for shp_path, band_name, use_eco_id in SHAPEFILES:
        if not os.path.exists(shp_path):
            print(f"⚠️  Skipping missing file: {os.path.basename(shp_path)}")
            continue
        
        print(f"  Processing: {os.path.basename(shp_path)}")
        
        # Load and clean shapefile
        gdf = load_and_clean_shapefile(shp_path, template_info['crs'])
        
        if gdf.empty:
            print(f"    ⚠️  No valid geometries found")
            # Add empty band
            empty_band = np.zeros((template_info['height'], template_info['width']), dtype="float32")
            all_bands.append(empty_band)
            band_names.append(band_name)
            continue
        
        print(f"    Loaded {len(gdf)} features")
        
        # Rasterize
        rasterized = rasterize_shapefile(gdf, template_info, use_eco_id)
        
        # Clip to template extent
        clipped = clip_to_template_extent(rasterized, TEMPLATE_TIF)
        
        all_bands.append(clipped)
        band_names.append(band_name)
        
        if use_eco_id:
            unique_vals = len(np.unique(clipped[clipped > 0]))
            print(f"    ✓ Added ecoregions band with {unique_vals} unique regions")
        else:
            valid_pixels = np.sum(clipped == 1)
            print(f"    ✓ Added binary band with {valid_pixels:,} pixels")
        
        # Save individual mask
        mask_output = f"{OUTPUT_MASKS_DIR}/{band_name}_mask_1km.tif"
        mask_profile = template_info['profile'].copy()
        mask_profile.update({
            "count": 1,
            "dtype": "float32",
            "compress": "LZW",
            "tiled": True,
            "nodata": 0
        })
        
        with rasterio.open(mask_output, "w", **mask_profile) as dst:
            dst.write(clipped, 1)
        
        print(f"    ✓ Saved mask → {os.path.basename(mask_output)}")
    
    # Stack all bands
    print(f"\nStacking {len(all_bands)} bands...")
    stacked_data = np.array(all_bands)
    
    # Create output profile
    output_profile = template_info['profile'].copy()
    output_profile.update({
        "count": len(all_bands),
        "dtype": "float32",
        "compress": "LZW",
        "tiled": True,
        "blockxsize": 512,
        "blockysize": 512,
        "nodata": np.nan
    })
    
    # Write stacked output
    with rasterio.open(OUTPUT_STACK, "w", **output_profile) as dst:
        dst.write(stacked_data)
        
        # Add band descriptions
        for i, name in enumerate(band_names, 1):
            dst.set_band_description(i, name)
    
    print(f"✓ Saved stacked raster → {os.path.basename(OUTPUT_STACK)}")
    
    # Create visualization
    print(f"\nCreating visualization...")
    create_visualization(stacked_data, band_names, OUTPUT_VISUALIZATION)
    
    # Summary
    print(f"\n" + "=" * 60)
    print("SUMMARY")
    print("=" * 60)
    print(f"Total bands: {len(all_bands)}")
    print(f"Dimensions: {template_info['width']} x {template_info['height']}")
    print(f"CRS: {template_info['crs']}")
    print(f"\nBand composition:")
    
    for i, name in enumerate(band_names, 1):
        band_data = stacked_data[i-1]
        if i == 2:  # Protected areas
            valid_pixels = np.sum(band_data == 1)
            print(f"  Band {i}: {name} (binary, {valid_pixels:,} pixels)")
        elif i == 8:  # Ecoregions
            unique_regions = len(np.unique(band_data[band_data > 0]))
            valid_pixels = np.sum(band_data > 0)
            print(f"  Band {i}: {name} (integer, {unique_regions} regions, {valid_pixels:,} pixels)")
        elif i >= 4:  # Other shapefile-derived
            valid_pixels = np.sum(band_data == 1)
            print(f"  Band {i}: {name} (binary, {valid_pixels:,} pixels)")
        else:  # Raster-derived
            valid_pixels = np.sum(~np.isnan(band_data))
            print(f"  Band {i}: {name} (continuous, {valid_pixels:,} pixels)")
    
    print(f"\nOutput files:")
    print(f"  Main stack: {OUTPUT_STACK}")
    print(f"  Individual masks: {OUTPUT_MASKS_DIR}/")
    print(f"  Visualization: {OUTPUT_VISUALIZATION}")
    
    print(f"\n✅ Merge completed successfully!")

if __name__ == "__main__":
    main()