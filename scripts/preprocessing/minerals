# csv_to_geotiff_points.py
# Convert a CSV with point coordinates (Longitude, Latitude) to a GeoTIFF grid.

import csv
import os
import numpy as np
import pandas as pd
import rasterio
from rasterio.transform import from_origin
import matplotlib.pyplot as plt
from pathlib import Path

# Optional plotting libraries
try:
    import plotly.express as px
    import plotly.graph_objects as go
    PLOTLY_AVAILABLE = True
except ImportError:
    PLOTLY_AVAILABLE = False

try:
    import cartopy.crs as ccrs
    import cartopy.feature as cfeature
    CARTOPY_AVAILABLE = True
except ImportError:
    CARTOPY_AVAILABLE = False

# ========= User config =========
CSV_PATH   = "Global_REE_occurrence_database.csv"   # <-- your file
OUT_TIF    = "REE_occurrence_count_025deg.tif"      # output filename
RES_DEG    = 0.25                                   # grid cell size in degrees
CRS_EPSG   = "EPSG:4326"                            # WGS84
AGG_KIND   = "count"                                 
# Options for AGG_KIND:
#   "count"  -> number of points in each cell
#   "presence" -> 0/1 (presence/absence)
#   "sum"    -> sum over VALUE_COLUMN
#   "mean"   -> mean over VALUE_COLUMN
#   "max"    -> max over VALUE_COLUMN
#   "min"    -> min over VALUE_COLUMN
VALUE_COLUMN = None  # set to e.g. "RR_TREOgrd" if using sum/mean/max/min

NODATA = {
    "count": 0.0,
    "presence": 255,     # presence uses uint8
    "sum": 0.0,
    "mean": np.nan,
    "max": np.nan,
    "min": np.nan
}.get(AGG_KIND, 0.0)
# =================================

def read_csv_smart(path: str) -> pd.DataFrame:
    # sniff delimiter
    with open(path, "r", encoding="utf-8", errors="ignore") as f:
        sample = f.read(65536)
    try:
        dialect = csv.Sniffer().sniff(sample, delimiters=[",",";","\t","|"])
        sep = dialect.delimiter
    except Exception:
        sep = ","
    return pd.read_csv(path, sep=sep, engine="python", encoding="utf-8", on_bad_lines='skip')

def detect_lon_lat_cols(columns):
    cols_lower = {c.lower(): c for c in columns}
    lon_cands = ["longitude","lon","long","lng","x","lon_dd","longitude_dd","east","easting"]
    lat_cands = ["latitude","lat","y","lat_dd","latitude_dd","north","northing"]
    lon = next((cols_lower[c] for c in lon_cands if c in cols_lower), None)
    lat = next((cols_lower[c] for c in lat_cands if c in cols_lower), None)
    if lon is None or lat is None:
        raise ValueError(f"Could not find lon/lat columns in {list(columns)}.")
    return lon, lat

def aggregate_to_grid(df, lon_col, lat_col, agg_kind, res_deg, value_col=None):
    # numeric + bounds filter
    df = df.copy()
    df[lon_col] = pd.to_numeric(df[lon_col], errors="coerce")
    df[lat_col] = pd.to_numeric(df[lat_col], errors="coerce")
    if value_col:
        df[value_col] = pd.to_numeric(df[value_col], errors="coerce")
    df = df.dropna(subset=[lon_col, lat_col])
    df = df[(df[lon_col]>=-180)&(df[lon_col]<=180)&(df[lat_col]>=-90)&(df[lat_col]<=90)]

    if df.empty:
        raise ValueError("No valid coordinate rows after cleaning.")

    # bounds + 1-cell pad
    minx, maxx = df[lon_col].min(), df[lon_col].max()
    miny, maxy = df[lat_col].min(), df[lat_col].max()
    pad = res_deg
    minx, maxx = minx - pad, maxx + pad
    miny, maxy = miny - pad, maxy + pad

    width  = int(np.ceil((maxx - minx) / res_deg))
    height = int(np.ceil((maxy - miny) / res_deg))

    # choose weights for histogram2d
    lat_vals = df[lat_col].to_numpy()
    lon_vals = df[lon_col].to_numpy()

    if agg_kind in ("count", "presence"):
        weights = np.ones(len(df), dtype=np.float32)
        grid, _, _ = np.histogram2d(
            lat_vals, lon_vals,
            bins=[height, width],
            range=[[miny, maxy],[minx, maxx]],
            weights=weights
        )
        if agg_kind == "presence":
            grid = (grid > 0).astype("uint8")
        else:
            grid = grid.astype("float32")

    elif agg_kind in ("sum","mean","max","min"):
        if not value_col:
            raise ValueError(f"VALUE_COLUMN must be set for agg '{agg_kind}'.")
        vals = df[value_col].to_numpy()
        # For sum/mean we can use weights; for max/min we’ll grid via bin indices
        if agg_kind in ("sum","mean"):
            sum_grid, _, _ = np.histogram2d(
                lat_vals, lon_vals,
                bins=[height, width],
                range=[[miny, maxy],[minx, maxx]],
                weights=vals
            )
            count_grid, _, _ = np.histogram2d(
                lat_vals, lon_vals,
                bins=[height, width],
                range=[[miny, maxy],[minx, maxx]],
                weights=np.isfinite(vals).astype(np.float32)
            )
            if agg_kind == "sum":
                grid = sum_grid.astype("float32")
            else:
                with np.errstate(invalid="ignore", divide="ignore"):
                    grid = (sum_grid / count_grid).astype("float32")
                grid[count_grid==0] = np.nan
        else:
            # max/min via cell indexing
            # compute row/col indices
            row = np.floor((lat_vals - miny) / res_deg).astype(int)
            col = np.floor((lon_vals - minx) / res_deg).astype(int)
            # clip any edge-overshoot
            row = np.clip(row, 0, height-1)
            col = np.clip(col, 0, width-1)
            grid = np.full((height, width), np.nan, dtype="float32")
            for r, c, v in zip(row, col, vals):
                if not np.isfinite(v):
                    continue
                if np.isnan(grid[r, c]):
                    grid[r, c] = v
                else:
                    if agg_kind == "max":
                        if v > grid[r, c]:
                            grid[r, c] = v
                    else:  # "min"
                        if v < grid[r, c]:
                            grid[r, c] = v
    else:
        raise ValueError(f"Unknown agg_kind: {agg_kind}")

    # flip to top-left origin
    grid = np.flipud(grid)

    transform = from_origin(minx, maxy, res_deg, res_deg)
    return grid, transform, width, height

def write_geotiff(path, grid, transform, crs, nodata):
    dtype = "uint8" if grid.dtype == np.uint8 else "float32"
    profile = {
        "driver": "GTiff",
        "height": grid.shape[0],
        "width": grid.shape[1],
        "count": 1,
        "dtype": dtype,
        "crs": crs,
        "transform": transform,
        "nodata": nodata,
        "tiled": True,
        "compress": "LZW"
    }
    with rasterio.open(path, "w", **profile) as dst:
        dst.write(grid, 1)

def plot_mineral_occurrences(df, lon_col, lat_col, output_dir="outputs"):
    """Plot mineral occurrences on a global map with both interactive and static versions."""
    output_dir = Path(output_dir)
    output_dir.mkdir(exist_ok=True)
    
    # Clean data for plotting
    df_plot = df.copy()
    df_plot[lon_col] = pd.to_numeric(df_plot[lon_col], errors="coerce")
    df_plot[lat_col] = pd.to_numeric(df_plot[lat_col], errors="coerce")
    df_plot = df_plot.dropna(subset=[lon_col, lat_col])
    df_plot = df_plot[(df_plot[lon_col] >= -180) & (df_plot[lon_col] <= 180) & 
                      (df_plot[lat_col] >= -90) & (df_plot[lat_col] <= 90)]
    
    print(f"Plotting {len(df_plot)} mineral occurrences...")
    
    # Create a simplified mineral type column for better visualization
    def create_mineral_type(row):
        """Create a simplified mineral type based on available columns."""
        # Check deposit type first (most specific)
        if pd.notna(row.get('Dep_Type', '')) and str(row.get('Dep_Type', '')).strip():
            dep_type = str(row.get('Dep_Type', '')).lower()
            if 'carbonatite' in dep_type:
                return 'Carbonatite'
            elif 'pegmatite' in dep_type:
                return 'Pegmatite'
            elif 'placer' in dep_type:
                return 'Placer'
            elif 'vein' in dep_type:
                return 'Vein'
            elif 'phosphorite' in dep_type:
                return 'Phosphorite'
            elif 'alkaline' in dep_type:
                return 'Alkaline Igneous'
        
        # Check commodities for multi-element deposits
        if pd.notna(row.get('Commods', '')) and str(row.get('Commods', '')).strip():
            commods = str(row.get('Commods', '')).lower()
            
            # Count different commodity types
            has_ree = 'ree' in commods
            has_nb_ta = any(metal in commods for metal in ['niobium', 'nb', 'tantalum', 'ta'])
            has_u_th = any(metal in commods for metal in ['uranium', 'u', 'thorium', 'th'])
            has_zr_hf = any(metal in commods for metal in ['zirconium', 'zr', 'hafnium', 'hf'])
            has_p = any(metal in commods for metal in ['phosphorus', 'p', 'phosphate'])
            has_v = any(metal in commods for metal in ['vanadium', 'v'])
            has_li_be = any(metal in commods for metal in ['lithium', 'li', 'beryllium', 'be'])
            has_gem = 'gem' in commods
            
            # Create composite categories
            if has_nb_ta and has_ree:
                return 'REE + Nb-Ta'
            elif has_u_th and has_ree:
                return 'REE + U-Th'
            elif has_zr_hf and has_ree:
                return 'REE + Zr-Hf'
            elif has_p and has_ree:
                return 'REE + P'
            elif has_li_be and has_ree:
                return 'REE + Li-Be'
            elif has_gem and has_ree:
                return 'REE + Gems'
            elif has_nb_ta:
                return 'Nb-Ta'
            elif has_u_th:
                return 'U-Th'
            elif has_zr_hf:
                return 'Zr-Hf'
            elif has_p:
                return 'P'
            elif has_v:
                return 'V'
            elif has_li_be:
                return 'Li-Be'
            elif has_gem:
                return 'Gems'
            elif has_ree:
                return 'REE Only'
        
        # Check REE minerals for more specific classification
        if pd.notna(row.get('REE_Mins', '')) and str(row.get('REE_Mins', '')).strip():
            ree_mins = str(row.get('REE_Mins', '')).lower()
            if 'monazite' in ree_mins and 'bastnäsite' in ree_mins:
                return 'Monazite + Bastnäsite'
            elif 'monazite' in ree_mins:
                return 'Monazite'
            elif 'bastnäsite' in ree_mins:
                return 'Bastnäsite'
            elif 'xenotime' in ree_mins:
                return 'Xenotime'
            elif 'allanite' in ree_mins:
                return 'Allanite'
            else:
                return 'Other REE Minerals'
        
        return 'Other'
    
    # Apply the mineral type classification
    df_plot['Mineral_Type'] = df_plot.apply(create_mineral_type, axis=1)
    
    # Use the new mineral type column for coloring
    color_col = 'Mineral_Type'
    
    print(f"Mineral type distribution:")
    print(df_plot['Mineral_Type'].value_counts())
    
    # Interactive plot with Plotly
    if PLOTLY_AVAILABLE:
        try:
            # Select key columns for hover information
            hover_cols = ['Name', 'Country', 'Commods', 'REE_Mins', 'Dep_Type', 'Mineral_Type']
            available_hover_cols = [col for col in hover_cols if col in df_plot.columns]
            
            fig = px.scatter_geo(
                df_plot,
                lat=lat_col,
                lon=lon_col,
                color=color_col,
                hover_data=available_hover_cols,
                projection='natural earth',
                opacity=0.8,
                height=800,
                title='Global Mineral Occurrences by Type',
                color_discrete_sequence=px.colors.qualitative.Set3
            )
            fig.update_layout(
                title_x=0.5,
                title_font_size=20,
                margin=dict(l=0, r=0, t=60, b=0),
                legend=dict(
                    orientation="v",
                    yanchor="top",
                    y=1,
                    xanchor="left",
                    x=1.02
                )
            )
            fig.update_traces(marker=dict(size=6))
            
            html_path = output_dir / 'mineral_occurrences_interactive.html'
            fig.write_html(str(html_path))
            print(f"Interactive map saved to: {html_path}")
        except Exception as e:
            print(f"Interactive plot failed: {e}")
    
    # Static plot with Matplotlib
    plt.figure(figsize=(16, 10))
    
    # Enhanced plotting with proper mineral type coloring
    if color_col and df_plot[color_col].nunique() > 1:
        unique_vals = df_plot[color_col].unique()
        colors = plt.cm.tab20(np.linspace(0, 1, len(unique_vals)))
        for i, val in enumerate(unique_vals):
            mask = df_plot[color_col] == val
            plt.scatter(df_plot.loc[mask, lon_col], df_plot.loc[mask, lat_col], 
                       s=12, c=[colors[i]], alpha=0.8, label=str(val), edgecolors='black', linewidth=0.3)
        plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left', fontsize=9)
    else:
        plt.scatter(df_plot[lon_col], df_plot[lat_col], s=12, c='red', alpha=0.8, edgecolors='black', linewidth=0.3)
    
    plt.xlabel('Longitude', fontsize=14)
    plt.ylabel('Latitude', fontsize=14)
    plt.title('Global Mineral Occurrences by Type', fontsize=18, pad=20)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    
    png_path = output_dir / 'mineral_occurrences_static.png'
    plt.savefig(png_path, dpi=300, bbox_inches='tight')
    plt.close()
    print(f"Static map saved to: {png_path}")

def main():
    df = read_csv_smart(CSV_PATH)
    lon_col, lat_col = detect_lon_lat_cols(df.columns)
    
    # Create plots
    plot_mineral_occurrences(df, lon_col, lat_col)
    
    # Original GeoTIFF creation
    grid, transform, width, height = aggregate_to_grid(
        df, lon_col, lat_col, AGG_KIND, RES_DEG, VALUE_COLUMN
    )

    # If presence, ensure uint8 0/1
    if AGG_KIND == "presence" and grid.dtype != np.uint8:
        grid = grid.astype("uint8")
    write_geotiff(OUT_TIF, grid, transform, CRS_EPSG, NODATA)

    print(f"Done. Wrote: {OUT_TIF}")
    print(f"Grid size: {grid.shape[0]} rows x {grid.shape[1]} cols (res {RES_DEG}°)")
    print(f"CRS: {CRS_EPSG} | Aggregation: {AGG_KIND} | NODATA: {NODATA}")

if __name__ == "__main__":
    main()