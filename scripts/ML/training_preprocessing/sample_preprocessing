#!/usr/bin/env python3

"""Temporal Transition Sampling Script

Purpose: Build a balanced dataset for predicting new WDPA establishment.
Input:  merged_panel_2000_2024.parquet
Process: Create lagged WDPA column, identify 0‚Üí1 transitions, sample ~2M rows.
Output: sample_training.parquet
"""

from __future__ import annotations

import os
import sys
import time
from pathlib import Path

import duckdb
import wandb


# Configuration
TOTAL_SAMPLE_SIZE = 2_000_000
POSITIVE_LIMIT = 1_000_000
RANDOM_STATE = 42


def main() -> None:
    start_time = time.time()
    
    # Get W&B credentials from environment
    wandb_api_key = os.environ.get("WANDB_API_KEY")
    wandb_entity = os.environ.get("WANDB_ENTITY")
    
    if not wandb_api_key:
        print("‚ö†Ô∏è  Warning: WANDB_API_KEY not found in environment")
    if not wandb_entity:
        print("‚ö†Ô∏è  Warning: WANDB_ENTITY not found in environment")
    
    # Initialize W&B
    print("üîÑ Initializing Weights & Biases...")
    wandb.init(
        project="ml-training-preprocessing",
        entity=wandb_entity,
        name=f"sample_preprocessing_{time.strftime('%Y%m%d_%H%M%S')}",
        config={
            "total_sample_size": TOTAL_SAMPLE_SIZE,
            "positive_limit": POSITIVE_LIMIT,
            "random_state": RANDOM_STATE,
        },
    )
    print("‚úÖ W&B connected")
    
    try:
        # Setup paths
        repo_root = Path(__file__).resolve().parents[3]
        input_path = repo_root / "data/ml/merged_panel_2000_2024.parquet"
        output_path = repo_root / "data/ml/sample_training.parquet"
        
        print(f"\nüìÇ Input: {input_path}")
        print(f"üìÇ Output: {output_path}")
        
        if not input_path.exists():
            raise FileNotFoundError(f"Input file not found: {input_path}")
        
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Initialize DuckDB
        con = duckdb.connect()
        num_threads = 8 if os.environ.get("SCRATCH") else 4
        con.execute(f"SET threads={num_threads}")
        con.execute("SET preserve_insertion_order=false")
        print(f"‚öôÔ∏è  DuckDB configured: {num_threads} threads")
        
        wandb.log({"config/threads": num_threads})
        
        # Escape paths for SQL
        escaped_in = str(input_path).replace("'", "''")
        escaped_out = str(output_path).replace("'", "''")
        
        # Step 1: Create lagged WDPA and identify transitions
        print("\nüîÑ Step 1: Computing lagged WDPA and transitions...")
        step1_start = time.time()
        
        transition_query = f"""
        WITH ordered_data AS (
            SELECT 
                *,
                LAG(WDPA_b1) OVER (PARTITION BY row, col ORDER BY year) AS WDPA_prev
            FROM read_parquet('{escaped_in}')
        )
        SELECT 
            *,
            CASE 
                WHEN WDPA_prev = 0 AND WDPA_b1 = 1 THEN 1
                ELSE 0
            END AS transition_01
        FROM ordered_data
        WHERE WDPA_prev IS NOT NULL
        """
        
        # Create a temporary view for efficiency
        con.execute(f"CREATE TEMP VIEW transitions AS ({transition_query})")
        
        step1_time = time.time() - step1_start
        print(f"   ‚úÖ Completed in {step1_time:.1f}s")
        wandb.log({"timing/step1_seconds": step1_time})
        
        # Step 2: Count positives and negatives
        print("\nüîÑ Step 2: Counting transitions...")
        step2_start = time.time()
        
        counts = con.execute("""
            SELECT 
                SUM(transition_01) AS positives,
                SUM(CASE WHEN transition_01 = 0 THEN 1 ELSE 0 END) AS negatives,
                COUNT(*) AS total,
                MIN(year) AS year_min,
                MAX(year) AS year_max
            FROM transitions
        """).fetchone()
        
        positives, negatives, total, year_min, year_max = counts
        
        print(f"   Total rows (with lagged data): {total:,}")
        print(f"   Positive transitions (0‚Üí1):    {positives:,}")
        print(f"   Negative transitions:          {negatives:,}")
        print(f"   Year range:                    {year_min}‚Äì{year_max}")
        
        step2_time = time.time() - step2_start
        wandb.log({
            "data/total_rows": total,
            "data/positives": positives,
            "data/negatives": negatives,
            "data/positive_ratio": positives / total if total > 0 else 0,
            "data/year_min": year_min,
            "data/year_max": year_max,
            "timing/step2_seconds": step2_time,
        })
        
        if positives == 0:
            raise ValueError("No positive transitions found! Cannot build training sample.")
        
        # Step 3: Determine sampling strategy
        print("\nüîÑ Step 3: Determining sampling strategy...")
        
        sample_positives = min(POSITIVE_LIMIT, positives)
        sample_negatives = min(sample_positives, negatives)  # Match positives for balance
        total_sample = sample_positives + sample_negatives
        
        print(f"   Sampling {sample_positives:,} positives (of {positives:,} available)")
        print(f"   Sampling {sample_negatives:,} negatives (of {negatives:,} available)")
        print(f"   Total sample size: {total_sample:,}")
        print(f"   Class balance: {sample_positives/total_sample*100:.1f}% positive")
        
        wandb.log({
            "sampling/positives": sample_positives,
            "sampling/negatives": sample_negatives,
            "sampling/total": total_sample,
            "sampling/balance": sample_positives / total_sample if total_sample > 0 else 0,
        })
        
        # Step 4: Sample and write output
        print("\nüîÑ Step 4: Sampling and writing output...")
        step4_start = time.time()
        
        sampling_query = f"""
        COPY (
            SELECT * FROM (
                -- All positives (up to limit)
                SELECT *
                FROM transitions
                WHERE transition_01 = 1
                USING SAMPLE reservoir({sample_positives} ROWS) REPEATABLE ({RANDOM_STATE})
            )
            UNION ALL
            SELECT * FROM (
                -- Equal number of negatives
                SELECT *
                FROM transitions
                WHERE transition_01 = 0
                USING SAMPLE reservoir({sample_negatives} ROWS) REPEATABLE ({RANDOM_STATE})
            )
        )
        TO '{escaped_out}'
        (FORMAT PARQUET, COMPRESSION ZSTD)
        """
        
        con.execute(sampling_query)
        
        step4_time = time.time() - step4_start
        print(f"   ‚úÖ Written to {output_path} in {step4_time:.1f}s")
        wandb.log({"timing/step4_seconds": step4_time})
        
        # Step 5: Verify output
        print("\nüîÑ Step 5: Verifying output...")
        
        verify_counts = con.execute(f"""
            SELECT 
                SUM(transition_01) AS pos_written,
                SUM(CASE WHEN transition_01 = 0 THEN 1 ELSE 0 END) AS neg_written,
                COUNT(*) AS total_written,
                COUNT(DISTINCT year) AS n_years,
                MIN(year) AS min_year,
                MAX(year) AS max_year
            FROM read_parquet('{escaped_out}')
        """).fetchone()
        
        pos_written, neg_written, total_written, n_years, min_year, max_year = verify_counts
        file_size_mb = output_path.stat().st_size / (1024 * 1024)
        total_time = time.time() - start_time
        
        # Print summary
        print("\n" + "="*70)
        print("‚úÖ SAMPLING COMPLETE")
        print("="*70)
        print(f"  Total rows:       {total_written:,}")
        print(f"  Positives (0‚Üí1):  {pos_written:,} ({pos_written/total_written*100:.1f}%)")
        print(f"  Negatives:        {neg_written:,} ({neg_written/total_written*100:.1f}%)")
        print(f"  Years covered:    {n_years} years ({min_year}‚Äì{max_year})")
        print(f"  File size:        {file_size_mb:.1f} MB")
        print(f"  Total time:       {total_time:.1f}s ({total_time/60:.1f} min)")
        print("="*70)
        
        # Log final results to W&B
        wandb.log({
            "output/total_rows": total_written,
            "output/positives": pos_written,
            "output/negatives": neg_written,
            "output/balance": pos_written / total_written if total_written > 0 else 0,
            "output/n_years": n_years,
            "output/year_min": min_year,
            "output/year_max": max_year,
            "output/file_size_mb": file_size_mb,
            "timing/total_seconds": total_time,
            "timing/total_minutes": total_time / 60,
            "status": "success",
        })
        
        # Warn if imbalanced
        balance = pos_written / total_written if total_written > 0 else 0
        if balance < 0.4 or balance > 0.6:
            print(f"\n‚ö†Ô∏è  Warning: Class balance is {balance*100:.1f}% (target: 50%)")
            wandb.alert(
                title="Class Imbalance Detected",
                text=f"Class balance is {balance*100:.1f}% positive",
                level=wandb.AlertLevel.WARN
            )
        
        print("\n‚úÖ All done!")
        
    except Exception as e:
        error_msg = f"{type(e).__name__}: {str(e)}"
        print(f"\n‚ùå ERROR: {error_msg}")
        wandb.log({
            "status": "failed",
            "error_type": type(e).__name__,
            "error_message": str(e),
        })
        raise
    
    finally:
        wandb.finish()
        print("üèÅ W&B run finished")


if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"\n‚ùå Script failed: {e}", file=sys.stderr)
        sys.exit(1)
